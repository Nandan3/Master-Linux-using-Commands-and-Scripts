	} Shell scripting:
		1. $vi demo.sh
		2. $chmod +x demo.sh
		3. $./demo.sh
		
	§ Projects:
	
	○ Task 1: how to install git software in multiple flavors (Linux, MacOS, windows) of OS?
	
	Git_install.sh:
	
	#!/bin/bash
	echo "script to install git"
	
	if [ $(uname) == "Linux" ]; then
	  echo "this is linux box, installing git"
	  yum install git -y
	
	elif [ $(uname) == "Darwin" ]; then
	  echo "this is MacOS"
	  brew install git
	
	else
	  echo "not installing"
	fi
	
	


○ Task 2: Project to check disk utilization (altering the message)
	
	Options:
	-d >> delimitor
	-f 1>> first field
	
	Disk_utilisation.sh:
	
	#!/bin/bash
	echo "checking disk utilization in Linux"
	
	disk_size = `df -h | grep "/dev/mapper/centos-root" | awk '{print $5}' | cut -d '%' -f 1
	
	if [ $disk_size -gt 80 ];
	then
	  echo "disk is utilised more than 80%, expand disk or delete files soon"
	else
	  echo "enough disk is available"
	fi
	
	
	

○ Task 3: Find the first 10 biggest file in the file system and write the output to a file.
	
	Biggest_file.sh:
	
	#!/bin/bash
	
	echo "Biggest files in the file system"
	file_path="$1"
	echo $file_path
	 
	du -ah $file_path | sort -hr | head -n 5 > /temp/filesize.txt
	 
	echo "list of biggest files in $file_path path are:"
	cat /tmp/filesize.txt
	
	


○ Task 4: Assume the application is developed using java code and the log files generated by application is stored under the directory "/tmp/application/current_date.log". This logs used when users need to debug any application related errors. But due to increased number of logs in this location, we want to write a shell script which will delete those logs which are created a month before.
	
	Delete_logs.sh:
	
	#!/bin/bash
	echo "this script delete files which are older than 30 days"
	path=$1
	echo $path
	find $path -mtime +30 -delete
	if [ $? -eq 0 ]; then
	    echo "Files are successfully deleted"
	else
	    echo "deletion having some issue"
	fi
		


○ Task 5: We need to install Prometheus software in our system, but we need to first check that if the file exists in our system or not. If it is already exists then it will not download, it just installs the same.
	
	Prometheus.sh:
	
	#!/bin/bash
	
	echo "Download the Prometheus binary"
	
	if [ -e  /home/ec2-user/Prometheus-3.7.0-rc.0.linux-amd64.tar.gz ]; then 
	  echo "file is already exist"
	  tar -zxvf /home/ec2-user/Prometheus-3.7.0-rc.0.linux-amd64.tar.gz
	
	else
	  echo "" Binary doesn't exist, download and extract it"
	Wget https://github.com/prometheus/prometheus/releases/download/v3.7.0-rc.0/prometheus-3.7.0-rc.0.linux-amd64.tar.gz
	tar -zxvf /home/ec2-user/Prometheus-3.7.0-rc.0.linux-amd64.tar.gz
	echo "File has been extracted, you can start Prometheus"
	fi
	


○ Task 6: We will loop over the content of directory specified and delete all the contents one by one.
	
	Deldirectory.sh:
	
	#!/bin/bash
	
	for folder in $(find -type d); do
	  echo "the folder is $folder"
	  
	  if [ -d test ]; then
	    echo "folder exist, removing it"
	    rm -rf test
	  
	  else
	    echo "folder doesn't exists"
	  fi
	Done
	
	


○ Task 7: Check if docker service is active or not
		
	Docservice.sh:
	
	#!/bin/bash
	echo "===status check of docker service==="
	status="`systemctl status docker | awk 'NR==3 {print}' | cut -d ':' -f 2 | cut -d '(' -f 1`"
	echo $status
	
	if [ $status = "active" ]; then
	  echo "service is running fine"
	else
	  echo "service is not running"
	fi
	
	


○ Task 8: Schedule a job automatically to run at regular interval and check if docker service is down, if it is down automatically start the service.
	
	Docservice.sh:
	
	#!/bin/bash
	echo "===status check of docker service==="
	status="`systemctl status docker | awk 'NR==3 {print}' | cut -d ':' -f 2 | cut -d '(' -f 1`"
	echo $status
	
	if [ $status = "active" ]; then
	  echo "service is running fine"
	else
	  echo "service is not running"
	  systemctl start docker
	fi
	
	Schedule it automatically:
	$cd /home/ec2-user
	$crontab -e
	
	Add: 
	 * * * * *  /home/ec2-user/Docservice.sh > dev/null
	
	


○ Task 9: Write a shell script which accepts a command line arguments and installs many software.
	
	Install_software.sh:
	
	#!/bin/bash
	
	if [[ $# -eq 0 ]]; then
	  echo "Usage: please provide software names as command line arguments"
	  exit 1
	fi
	
	if [[ $(id -u) -ne 0]]; then
	  echo "Please run from root user or with sudo privilage"
	  exit 2
	fi
	
	for software in $@; do
	  if which $softwares &> /dev/null; then
	    echo "Already $softwares is installed"
	  else
	    echo "Installing $softwares ….."
	    yum install $softwares -y &> /dev/null
	    if [[$? -eq 0 ]]; then
	      echo "Successfully installed $softwares packages"
	    else
	      echo "Unable to install $softwares"
	    fi
	  fi 
	done
	
	


○ Task 10: Project to read the user input and print the status of service in system
	
	Status_check.sh:
	
	#!/bin/bash
	echo " Welcome to service status check script "
	read -p "Enter the service name to check its status: " service_name
	if [ -z $service_name ];
	then
	        echo " Please eneter a valid service name "
	else
	        systemctl status $service_name
	fi
	
	


○ Task 11: write shell script to check errors in error logs.
	
	Grep.sh:
	
	#!/bin/bash
	error_file=`cat /var/log/messages`
	matched_error=`grep -i error /var/log/messages`
	echo $matched_error
	if [[ $? -eq 0 ]];
	then
	        echo "found error in OS logs: $matched_error "
	else
	        echo "no error in message logs"
	fi
	
	


○ Task 12: create menu driven program which can do 4 actions addition, subtraction, multiplication and division.
	
	Calculator.sh:
	
	#!/bin/bash
	clear
	echo "--------------------------------"
	echo "-------welcome to calculator----"
	echo "--------------------------------"
	read_input()
	{
	        read -p "Enter first number: " num1
	        read -p "Enter second number: " num2
	}
	echo -e "[a]addition\n[b]Subtraction\n[c]Multiplication\n[d]Division\n"
	read -p "Enter your choice: " choice
	case $choice in
	   [aA])
	        read_input
	        result=$((num1+num2))
	        echo "The result for your choice is: $result"
	        ;;
	   [bB])
	        read_input
	        result=$((num1-num2))
	        echo "The result for your choice is: $result"
	        ;;
	   [cC])
	        read_input
	        result=$((num1*num2))
	        echo "The result for your choice is: $result"
	        ;;
	   [dD])
	        read_input
	        result=$((num1/num2))
	        echo "The result for your choice is: $result"
	        ;;
	   *)
	       echo "Wrong choice"
	       ;;
	esac
	
	


○ Task 13: Usage of curl
	
	Curl.sh:
	
	#!/bin/bash
	
	URL="https://github.com/Kritika-git/Docker-Projects"
	#echo "%{http_code}"
	response=$(curl -s -w "%{http_code}"  $URL)
	
	http1_code=$(tail -n1 <<< "$response")  # get the last line
	content=$(sed '$ d' <<< "$response")   # get all but the last line which contains the status code
	
	echo "$http1_code"
	if [ $http1_code  == 200  ];
	then
	                echo "Request is working fine"
	        else
	                        echo "send slack message that request is denied"
	fi
	#echo "$content"
	
	


○ Task 14: write a shell script to help to generate CPU load alert for our system
	
	CPU_load.sh:
	
	#!/bin/bash
	
	 echo "CPU load average check"
	 load=`top -bn1 | grep load | awk '{printf "%.2f%%\t\t\n" , $(NF-2)}' | cut -d '%' -f1`
	 echo $load
	 if [[ $(load%.*) > 1 ]]; then
	   echo "CPU load is very high: $load"
	 else
	   echo "load is normal"
	 fi
	
	


○ Task 15: write a shell script to take backup of the directories in system and transfer it to a specific location.
	
	Backup.sh:
	
	#!/bin/bash
	
	backup_dirs=("/etc" "/home")
	dest_dir="/root/backup_today"
	mkdir -p $dest_dir
	backup_date=$(date +%b-%d-%y)
	
	echo "Starting backup of: ${backup_dirs[@]}"
	
	for i in "${backup_dirs[@]}"; do
	sudo tar -Pczf /tmp/$i-$backup_date.tar.gz $i
	if [ $? -eq 0 ]; then
	echo "$i backup succeeded."
	else
	echo "$i backup failed."
	fi
	cp /tmp/$i-$backup_date.tar.gz $dest_dir
	if [ $? -eq 0 ]; then
	echo "$i transfer succeeded."
	else
	echo "$i transfer failed."
	fi
	done
	
	sudo rm /tmp/*.gz
	echo "Backup is done."
	
	


○ Task 16: create a service in linux system which will monitor the disk usage every 2mins and store the information in log file.
	
	FS_utilisation.sh:
	
	#!/bin/bash
	# Script checks the FS utilisation every 120 sec and store it in a file
	
	 while true; do
	 date >> /var/log/fs-monitor.txt
	 sudo df -h >> /var/log/fs-monitor.txt
	 sleep 120
	 done
	
	Create service in: /etc/systemd/system/<service_name>.service
	Eg: /etc/systemd/system/fs-monitor.service
	
	
	
	$systemctl start fs-monitor.service
	$systemctl status fs-monitor.service
	
	


○ Task 17: write a shell script which will delete the user account, kill the process associated with that user. (day-20)
	
	User_kill_process.sh:
	
	#!/bin/bash
	#
	#Delete_User - Automates the 4 steps to remove an account
	#
	###############################################################
	# Define Functions
	#
	#####################################################
	function get_answer {
	#
	unset answer
	ask_count=0
	#
	while [ -z "$answer" ]    #While no answer is given, keep asking.
	do
	     ask_count=$[ $ask_count + 1 ]
	#
	     case $ask_count in   #If user gives no answer in time allotted
	     2)
	          echo
	          echo "Please answer the question."
	          echo
	     ;;
	     3)
	          echo
	          echo "One last try...please answer the question."
	          echo
	     ;;
	     4)
	          echo
	          echo "Since you refuse to answer the question..."
	          echo "exiting program."
	          echo
	          #
	          exit
	     ;;
	     esac
	#
	     if [ -n "$line2" ]
	     then               #Print 2 lines
	          echo $line1
	          echo -e $line2" \c"
	     else                    #Print 1 line
	          echo -e $line1" \c"
	     fi
	#
	#     Allow 60 seconds to answer before time-out
	     read -t 60 answer
	done
	# Do a little variable clean-up
	unset line1
	unset line2
	#
	}  #End of get_answer function
	#
	#####################################################
	function process_answer {
	#
	answer=$(echo $answer | cut -c1)
	#
	case $answer in
	y|Y)
	# If user answers "yes", do nothing.
	;;
	*)
	# If user answers anything but "yes", exit script
	        echo
	        echo $exit_line1
	        echo $exit_line2
	        echo
	        exit
	;;
	esac
	#
	# Do a little variable clean-up
	#
	unset exit_line1
	unset exit_line2
	#
	} #End of process_answer function
	#
	##############################################
	# End of Function Definitions
	#
	############# Main Script ####################
	# Get name of User Account to check
	#
	echo "Step #1 - Determine User Account name to Delete "
	echo
	line1="Please enter the username of the user "
	line2="account you wish to delete from system:"
	get_answer
	user_account=$answer
	#
	# Double check with script user that this is the correct User Account
	#
	line1="Is $user_account the user account "
	line2="you wish to delete from the system? [y/n]"
	get_answer
	#
	# Call process_answer funtion:
	#     if user answers anything but "yes", exit script
	#
	exit_line1="Because the account, $user_account, is not "
	exit_line1="the one you wish to delete, we are leaving the script..."
	process_answer
	#
	################################################################
	# Check that user_account is really an account on the system
	#
	user_account_record=$(cat /etc/passwd | grep -w $user_account)
	#
	if [ $? -eq 1 ]          # If the account is not found, exit script
	then
	     echo
	     echo "Account, $user_account, not found. "
	     echo "Leaving the script..."
	     echo
	     exit
	fi
	#
	echo
	echo "I found this record:"
	echo $user_account_record
	echo
	#
	line1="Is this the correct User Account? [y/n]"
	get_answer
	#
	#
	# Call process_answer function:
	#       if user answers anything but "yes", exit script
	#
	exit_line1="Because the account, $user_account, is not "
	exit_line2="the one you wish to delete, we are leaving the script..."
	process_answer
	#
	##################################################################
	# Search for any running processes that belong to the User Account
	#
	echo
	echo "Step #2 - Find process on system belonging to user account"
	echo
	#
	ps -u $user_account> /dev/null  #List user processes running.
	 
	case $? in
	1)     # No processes running for this User Account
	        #
	     echo "There are no processes for this account currently running."
	     echo
	;;
	0)   # Processes running for this User Account.
	     # Ask Script User if wants us to kill the processes.
	     #
	     echo "$user_account has the following process(es) running:"
	     ps -u $user_account
	     #
	     line1="Would you like me to kill the process(es)? [y/n]"
	     get_answer
	     #
	     answer=$(echo $answer | cut -c1)
	     #
	     case $answer in
	     y|Y)   # If user answers "yes",
	            # kill User Account processes.
	            #
	            echo
	            echo "Killing off process(es)..."
	            #
	            # List user process running code in command_1
	            command_1="ps -u $user_account --no-heading"
	            #
	            # Create command_3 to kill processes in variable
	            command_3="xargs -d \\n /usr/bin/sudo /bin/kill -9"
	            #
	            # Kill processes via piping commands together
	            $command_1 | gawk '{print $1}' | $command_3
	            #
	            echo
	            echo "Process(es) killed."
	     ;;
	     *)     #If user answers anything but "yes", do not kill.
	            echo
	            echo "Will not kill process(es)."
	     ;;
	     esac
	;;
	esac
	#################################################################
	# Create a report of all files owned by User Account
	#
	echo
	echo "Step #3 - Find files on system belonging to user account"
	echo
	echo "Creating a report of all files owned by $user_account."
	echo
	echo "It is recommended that you backup/archive these files,"
	echo "and then do one of two things:"
	echo "  1) Delete the files"
	echo "  2) Change the files' ownership to a current user account."
	echo
	echo "Please wait. This may take a while..."
	#
	report_date=$(date +%y%m%d)
	report_file="$user_account"_Files_"$report_date".rpt
	#
	find / -user $user_account> $report_file 2>/dev/null
	#
	echo
	echo "Report is complete."
	echo "Name of report:      $report_file"
	echo -n "Location of report: "; pwd
	echo
	####################################
	#  Remove User Account
	echo
	echo "Step #4 - Remove user account"
	echo
	#
	line1="Do you wish to remove $user_account's account from system? [y/n]"
	get_answer
	#
	# Call process_answer function:
	#       if user answers anything but "yes", exit script
	#
	exit_line1="Since you do not wish to remove the user account,"
	exit_line2="$user_account at this time, exiting the script..."
	process_answer
	#
	userdel $user_account          #delete user account
	echo
	echo "User account, $user_account, has been removed"
	echo
	#
	exit
	
	


○ Task 18: get mysql all running process using shell
	
	Mysql_proc.sh:
	
	#!/bin/bash
	
	# Define colors
	RESET="\033[0m"
	CYAN="\033[36m"
	YELLOW="\033[33m"
	GREEN="\033[32m"
	MAGENTA="\033[35m"
	RED="\033[31m"
	
	# MySQL credentials
	MYSQL_USER="root"  # Replace with your MySQL username
	MYSQL_PASS="devops"  # Replace with your MySQL password
	MYSQL_HOST="localhost"  # Change if not running MySQL locally
	
	# Run MySQL SHOW PROCESSLIST command
	RESULT=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "SHOW PROCESSLIST;" 2>/dev/null)
	
	# Check for errors
	if [[ $? -ne 0 ]]; then
	  echo -e "${RED}Error connecting to MySQL. Check your credentials.${RESET}"
	  exit 1
	fi
	
	# Process and colorize output
	echo -e "${CYAN}--- SHOW PROCESSLIST Result ---${RESET}"
	echo "$RESULT" | while IFS= read -r line; do
	  if [[ $line == *"Id"* && $line == *"Command"* ]]; then
	    # Header
	    echo -e "${YELLOW}${line}${RESET}"
	  else
	    # Data rows
	    echo "$line" | awk -v reset="$RESET" -v green="$GREEN" -v cyan="$CYAN" -v magenta="$MAGENTA" -v yellow="$YELLOW" '
	    {
	      printf cyan $1 reset "\t" green $2 reset "\t" magenta $3 reset "\t" yellow $4 reset "\t";
	      for (i = 5; i <= NF; i++) printf $i " ";
	      printf "\n";
	    }'
	  fi
	done
	
	


○ Task 19: weather forecast of any city
	
	Curl-weather.sh:
	
	#!/bin/bash
	
	# Function to display usage
	show_usage() {
	  echo "Usage: $0 <city_name>"
	  echo "Example: $0 Delhi"
	}
	
	# Check if city is provided
	CITY="$1"
	if [ -z "$CITY" ]; then
	  echo "Error: City name not provided."
	  show_usage
	  exit 1
	fi
	
	# Displaying a loading message
	echo "Fetching weather details for $CITY..."
	
	# Fetch weather data
	WEATHER=$(curl -s "https://wttr.in/${CITY}?format=3")
	
	# Check if the response is valid
	if [[ "$WEATHER" == *"Unknown location"* ]]; then
	  echo "Error: Unable to fetch weather details for '$CITY'. Please check the city name."
	  exit 1
	fi
	
	# Display the weather details
	echo "===================================="
	echo "         WEATHER REPORT             "
	echo "===================================="
	echo "$WEATHER"
	echo "===================================="
	
	# Suggest viewing the full report
	echo "For more details, visit: https://wttr.in/${CITY}"
	
	


○ Task 20: Lists users having root privileges
	
	Root_users.sh:
	
	#!/bin/bash
	
	echo "Checking users with root privileges..."
	
	# 1. Users with UID 0 (direct root access)
	echo "Users with UID 0 (direct root access):"
	awk -F: '$3 == 0 {print $1}' /etc/passwd
	
	# 2. Users in the 'sudo' group (indirect root access via sudo)
	echo "Users in the 'sudo' group:"
	getent group sudo | awk -F: '{print $4}' | tr ',' '\n'
	
	# 3. Users explicitly granted sudo privileges in the sudoers file
	echo "Users with explicit sudo privileges in /etc/sudoers:"
	awk '/^[^#].*ALL=\(ALL\)/ {print $1}' /etc/sudoers
	
	# 4. Users in files under /etc/sudoers.d (additional sudo privileges)
	echo "Users with sudo privileges in /etc/sudoers.d:"
	for file in /etc/sudoers.d/*; do
	  [ -f "$file" ] && awk '/^[^#].*ALL=\(ALL\)/ {print $1}' "$file"
	done
	
	


○ Task 21: Unmount particular disk drive
	
	Unmount.sh:
	
	#!/bin/bash
	
	 # Define the mount point or device
	 MOUNT_POINT="/mnt/wsl/docker-desktop/docker-desktop-user-distro"  # Change to your mount point(The directory where the disk is mounted)
	 DEVICE="/dev/sdc"         # Change to your disk/device
	
	 # Function to check if disk is in use
	 #This function checks if there are any processes using files on the disk using the lsof +D command.
	 #If the disk is in use, it will print an error message and return a non-zero exit code (1), preventing unmounting.
	
	 check_disk_usage() {
	     lsof +D "$MOUNT_POINT" > /dev/null 2>&1
	     if [ $? -eq 0 ]; then
	         echo "Error: Disk is still in use. Please close all files and processes accessing the disk."
	         return 1
	     else
	         return 0
	     fi
	 }
	 #The script first checks whether the disk is mounted using mount | grep.
	 # If the disk is not mounted, it will print an error message and exit.
	 # Check if the disk is mounted
	 if mount | grep "on $MOUNT_POINT " > /dev/null; then
	     echo "Disk is mounted at $MOUNT_POINT."
	
	     # Step 1: Ensure no files are in use on the disk
	     echo "Checking if disk is in use..."
	     if ! check_disk_usage; then
	         echo "Unable to unmount disk. Please stop processes using the disk."
	         exit 1
	     fi
	 #The script tries to unmount the disk using sudo umount. If the unmount is successful, it prints a success message.
	 # If it fails, it suggests that the disk may need to be forcefully unmounted (though this is avoided in this script).
	     # Step 2: Attempt to unmount the disk
	     echo "Attempting to unmount $DEVICE at $MOUNT_POINT..."
	     sudo umount "$MOUNT_POINT"
	
	     # Check if umount was successful
	     if [ $? -eq 0 ]; then
	         echo "Successfully unmounted $DEVICE from $MOUNT_POINT."
	     else
	         echo "Error: Failed to unmount $DEVICE. You may need to force unmount."
	     fi
	 #The script handles errors gracefully by printing messages and exiting when necessary (e.g., if the disk is in use or not mounted).
	 else
	     echo "Error: $DEVICE is not mounted at $MOUNT_POINT."
	     exit 1
	 fi
	
	
	
	
	
